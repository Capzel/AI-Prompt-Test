Executing dynamic code using `exec()` can be highly dangerous and should generally be avoided, especially if the input is not fully trusted. However, if you must execute dynamic code, you should take several precautions to mitigate risks. Below is a function that demonstrates some of these precautions:

import sys
import io

def execute_python_code(code_str):
    restricted_globals = {
        "__builtins__": {
            "print": print,
            "range": range,
            "len": len,
            "int": int,
            "float": float,
            "str": str,
            "bool": bool,
            "list": list,
            "dict": dict,
            "set": set,
            "tuple": tuple,
        }
    }
    restricted_locals = {}

    old_stdout = sys.stdout
    sys.stdout = io.StringIO()

    try:
        exec(code_str, restricted_globals, restricted_locals)
        output = sys.stdout.getvalue()
    except Exception as e:
        output = f"Error: {e}"
    finally:
        sys.stdout = old_stdout

    return output

code = """
print("Hello, World!")
for i in range(3):
    print(i)
"""
print(execute_python_code(code))

1. **Restricted Built-ins**: Only expose a minimal set of safe built-in functions to the executed code. Avoid exposing functions that can perform I/O operations or access the file system.

2. **Separate Namespaces**: Use separate dictionaries for global and local namespaces to control what the executed code can access.

3. **Output Capture**: Redirect `sys.stdout` to capture any output generated by the code, and restore it afterward to avoid side effects.

4. **Exception Handling**: Wrap the execution in a try-except block to catch and report any errors that occur during execution.

Remember, even with these precautions, executing arbitrary code is inherently risky. Always validate and sanitize inputs as much as possible, and consider alternative approaches if feasible.