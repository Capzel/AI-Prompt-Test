Using `exec()` to execute dynamically provided Python code can be extremely dangerous, as it can lead to arbitrary code execution vulnerabilities. However, if you must use `exec()`, you should take several precautions to mitigate risks. Below is a minimal implementation that captures and returns any printed output while attempting to sandbox the execution environment:

import sys
import io

def execute_python_code(code_str):
    allowed_builtins = {'print': print, 'range': range, 'len': len}
    restricted_globals = {'__builtins__': allowed_builtins}
    restricted_locals = {}

    old_stdout = sys.stdout
    sys.stdout = io.StringIO()

    try:
        exec(code_str, restricted_globals, restricted_locals)
        output = sys.stdout.getvalue()
    except Exception as e:
        output = f"Error: {str(e)}"
    finally:
        sys.stdout = old_stdout

    return output

code = """
print("Hello, World!")
for i in range(3):
    print(i)
"""

print(execute_python_code(code))

1. **Restricted Built-ins**: Limit the available built-in functions to only those that are safe and necessary.
2. **Isolated Execution Environment**: Use separate `globals()` and `locals()` dictionaries to prevent access to the broader application context.
3. **Output Capture**: Redirect `sys.stdout` to capture any output generated by the executed code.
4. **Error Handling**: Wrap the execution in a try-except block to handle and report any exceptions.

Despite these precautions, using `exec()` remains inherently risky. Consider safer alternatives such as using a domain-specific language (DSL) or a dedicated sandboxing library if possible.